const express = require('express');
const router = express.Router();
const { articlesDao, highlightsDao } = require('../lib/daoFactory');
const { authenticateToken } = require('../middleware/auth');
const { validateHighlight, handleValidationErrors } = require('../middleware/validation');

// --- Helpers (exposed on router for easier testing) ----------------------

/**
 * Generate a short title from the highlighted text (used when no title provided)
 */
const generateTitle = txt => {
  if (!txt) return '';
  const words = txt.trim().split(/\s+/).slice(0, 6);
  let t = words.join(' ');
  if (t.length < txt.trim().length) t = `${t}...`;
  return t;
};

/**
 * Validate the annotations payload. Returns { valid: bool, error?: string }
 * Allowed values:
 *  - undefined => not provided
 *  - null => explicit remove annotations
 *  - object => single annotation (not array)
 */
const validateAnnotationsPayload = annotations => {
  if (annotations === undefined) return { valid: true };
  if (annotations === null) return { valid: true };
  if (Array.isArray(annotations)) return { valid: false, error: '`annotations` must be a single object, not an array' };
  if (typeof annotations !== 'object') return { valid: false, error: '`annotations` must be an object with `title` and/or `note` when provided' };
  return { valid: true };
};

/** Build a new highlight object (does not persist) */
const buildNewHighlight = ({ articleId, userId, text, color, position, annotations }) => {
  const providedTitle = annotations && annotations.title ? annotations.title : null;
  const providedNote = annotations && annotations.note !== undefined ? annotations.note : '';

  // Note: ID will be generated by the DAO when creating
  return {
    articleId,
    userId,
    text,
    annotations: {
      title: providedTitle || generateTitle(text),
      note: providedNote || ''
    },
    color: color || '#fef08a',
    position: {
      start: position.start,
      end: position.end
    },
    createdAt: new Date(),
    updatedAt: new Date()
  };
};

/** Build an updated highlight object based on an existing highlight and request body.
 * Returns { updated, error } where updated is the new object (not persisted)
 */
const buildUpdatedHighlight = (highlight, body) => {
  const { annotations: newAnnotations, text: newText, color: newColor} = body;

  // Do not allow changing the highlighted text
  if (newText !== undefined && newText !== highlight.text) {
    return { error: { status: 400, message: 'Highlighted text cannot be modified. To remove the highlight, delete it instead.' } };
  }

  // Validate annotations payload
  const validation = validateAnnotationsPayload(newAnnotations);
  if (!validation.valid) return { error: { status: 400, message: validation.error } };

  const updatedHighlight = { ...highlight };

  if (newAnnotations !== undefined) {
    if (newAnnotations === null) {
      updatedHighlight.annotations = null;
    } else {
      const { title: naTitle, note: naNote } = newAnnotations;
      updatedHighlight.annotations = { ...(highlight.annotations || {}) };
      if (naTitle !== undefined) updatedHighlight.annotations.title = naTitle;
      if (naNote !== undefined) updatedHighlight.annotations.note = naNote;
    }
  }

  if (newColor !== undefined) {
    updatedHighlight.color = newColor;
  }

  // preserve id/articleId/userId, update updatedAt
  updatedHighlight.id = highlight.id;
  updatedHighlight.articleId = highlight.articleId;
  updatedHighlight.userId = highlight.userId;
  updatedHighlight.updatedAt = new Date();
  // keep position unchanged (current behavior)
  updatedHighlight.position = highlight.position;

  return { updated: updatedHighlight };
};

// Attach helpers to router for tests to import via router._helpers
router._helpers = { generateTitle, validateAnnotationsPayload, buildNewHighlight, buildUpdatedHighlight };

// -------------------------------------------------------------------------

/**
 * GET /api/highlights
 * Retrieve all highlights (optionally filtered by userId)
 */
router.get('/', authenticateToken, async (req, res) => {
  try {
    // Filter by authenticated user
    const highlights = await highlightsDao.getAll({ userId: req.user.id });

    // Sort by creation date (newest first)
    highlights.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));

    res.json({
      success: true,
      count: highlights.length,
      data: highlights
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Server Error',
      message: error.message
    });
  }
});

/**
 * GET /api/highlights/article/:articleId
 * Get all highlights for a specific article
 */
router.get('/article/:articleId', authenticateToken, async (req, res) => {
  try {
    // First verify article belongs to user
    const article = await articlesDao.getById(req.params.articleId);
    if (!article) {
      return res.status(404).json({
        success: false,
        error: 'Article not found'
      });
    }

    if (article.userId !== req.user.id && article.userId !== String(req.user.id)) {
      return res.status(403).json({
        success: false,
        error: 'Access denied: You can only view highlights for your own articles'
      });
    }

    const highlights = await highlightsDao.getByArticleId(req.params.articleId);

    // Sort by position in article
    highlights.sort((a, b) => a.position.start - b.position.start);

    res.json({
      success: true,
      articleId: isNaN(Number(req.params.articleId)) ? req.params.articleId : Number(req.params.articleId),
      count: highlights.length,
      data: highlights
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Server Error',
      message: error.message
    });
  }
});

/**
 * POST /api/highlights
 * Create a new highlight/annotation (mock - doesn't persist)
 */
router.post('/', authenticateToken, validateHighlight, handleValidationErrors, async (req, res) => {
  try {
    const { articleId, text, color, position, annotations } = req.body;
    const userId = req.user.id; // Get from authenticated user

    // Validate required fields
    if (!articleId || !text || !position) {
      return res.status(400).json({
        success: false,
        error: 'Missing required fields: articleId, text, position'
      });
    }

    // Verify article belongs to user
    const article = await articlesDao.getById(articleId);
    if (!article) {
      return res.status(404).json({
        success: false,
        error: 'Article not found'
      });
    }

    if (article.userId !== userId && article.userId !== String(userId)) {
      return res.status(403).json({
        success: false,
        error: 'Access denied: You can only create highlights for your own articles'
      });
    }

    if (position.start === undefined || position.end === undefined) {
      return res.status(400).json({
        success: false,
        error: 'Position must include start and end character positions'
      });
    }

    // Validate annotations and build the new highlight using helper
    const validation = router._helpers.validateAnnotationsPayload(annotations);
    if (!validation.valid) {
      return res.status(400).json({ success: false, error: validation.error });
    }

    const highlightData = router._helpers.buildNewHighlight({ articleId, userId, text, color, position, annotations });
    const newHighlight = await highlightsDao.create(highlightData);

    // Update article's hasAnnotations to true
    try {
      await articlesDao.update(articleId, { hasAnnotations: true });
    } catch (e) {
      console.error('Failed to update article hasAnnotations:', e);
    }

    res.status(201).json({
      success: true,
      data: newHighlight,
      message: 'Highlight created successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Server Error',
      message: error.message
    });
  }
});

/**
 * PUT /api/highlights/:id
 * Update a highlight/annotation (mock - doesn't persist)
 */
router.put('/:id', authenticateToken, validateHighlight, handleValidationErrors, async (req, res) => {
  try {
    const highlight = await highlightsDao.getById(req.params.id);
    
    if (!highlight) {
      return res.status(404).json({
        success: false,
        error: 'Highlight not found'
      });
    }

    // Verify highlight belongs to authenticated user
    if (highlight.userId !== req.user.id && highlight.userId !== String(req.user.id)) {
      return res.status(403).json({
        success: false,
        error: 'Access denied: You can only update your own highlights'
      });
    }
    // Build updated object carefully to support nested `annotations` while
    // preserving id/articleId/userId and updatedAt.
    const {annotations: newAnnotations} = req.body;

    // Validate annotations payload: only accept a single object (or null to remove annotations)
    if (newAnnotations !== undefined && newAnnotations !== null && typeof newAnnotations !== 'object') {
      return res.status(400).json({
        success: false,
        error: '`annotations` must be an object with `title` and/or `note`, or null to remove annotations'
      });
    }
    if (Array.isArray(newAnnotations)) {
      return res.status(400).json({
        success: false,
        error: '`annotations` must be a single object, not an array'
      });
    }

    const result = router._helpers.buildUpdatedHighlight(highlight, req.body);
    if (result.error) {
      return res.status(result.error.status).json({ success: false, error: result.error.message });
    }

    const updated = await highlightsDao.update(req.params.id, result.updated);

    res.json({ success: true, data: updated, message: 'Highlight updated successfully' });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Server Error',
      message: error.message
    });
  }
});

/**
 * DELETE /api/highlights/:id
 * Delete a highlight (mock - doesn't persist)
 */
router.delete('/:id', authenticateToken, async (req, res) => {
  try {
    const highlight = await highlightsDao.getById(req.params.id);
    
    if (!highlight) {
      return res.status(404).json({
        success: false,
        error: 'Highlight not found'
      });
    }

    // Verify highlight belongs to authenticated user
    if (highlight.userId !== req.user.id && highlight.userId !== String(req.user.id)) {
      return res.status(403).json({
        success: false,
        error: 'Access denied: You can only delete your own highlights'
      });
    }

    const articleId = highlight.articleId;
    await highlightsDao.delete(req.params.id);

    // Check if article still has any highlights
    try {
      const remainingHighlights = await highlightsDao.getByArticle(articleId);
      const hasAnnotations = remainingHighlights && remainingHighlights.length > 0;
      await articlesDao.update(articleId, { hasAnnotations });
    } catch (e) {
      console.error('Failed to update article hasAnnotations:', e);
    }

    res.json({
      success: true,
      message: 'Highlight deleted successfully',
      data: { id: highlight.id }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Server Error',
      message: error.message
    });
  }
});

module.exports = router;
